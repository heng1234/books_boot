{"./":{"url":"./","title":"目录","keywords":"","body":"目录 项目地址 springboot介绍 springboot集成lombok springboot基础配置 springboot使用banner springboot读取配置文件 springboot访问路径配置和Profile配置说明 springboot集成mybatis(xml形式) springboot AOP记录用户操作日志 Spring Boot 使用thymeleaf SpringBoot整合Thymeleaf——自定义标签 Spring Boot MyBatis配置Druid多数据源 SpringBoot 中使用Redis缓存 SpringBoot 中使用ehcache缓存 springboot使用拦截器-过滤器-servlet-listener Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-11-06 10:39:50 "},"springboot.html":{"url":"springboot.html","title":"springboot介绍","keywords":"","body":"springboot介绍 Spring Boot四大核心： 1.自动配置：针对很多Spring应用程序和常用的应用功能，Spring Boot能自动提供相关配置； 2.起步依赖：告诉Spring需要什么功能，它就能引入需要的依赖库； 3.Actuator：让你能深入运行中的Spring Boot应用程序，监控程序的内部信息； 4.命令行界面：这个为Spring Boot的可选特性，主要是针对Groovy的。 官网地址:https://spring.io/projects/spring-boot/ 特征 创建独立的Spring应用程序 直接嵌入Tomcat，Jetty或Undertow（无需部署WAR文件） 提供自以为是的“入门”依赖项，以简化构建配置 尽可能自动配置Spring和3rd Party库 提供生产就绪的功能，例如指标，运行状况检查和外部配置 完全没有代码生成，也不需要XML配置 优点 快速构建项目 对主流开发框架的无配置集成 项目可独立运行，无需外部依赖 Servlet 容器 提供运行时的应用监控 极大地提高了开发、部署效率 与云计算的天然集成 起步依赖 缺点 版本迭代速度很快，一些模块改动很大 由于不用自己做配置，报错时很难定位 网上现成的解决方案比较少 可以进入该网站快速创建springboot项目 https://start.spring.io/ 也可以通过idea进行创建 这里不讲解springboot项目的创建 下一章:springboot集成lombok Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-10-17 18:36:45 "},"lombok.html":{"url":"lombok.html","title":"springboot集成lombok","keywords":"","body":"springboot2.x集成lombok插件 什么是lombok?(项目地址:https://github.com/heng1234/springboot2.x/tree/master/boot_lombok) Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。 Lombok也存在一定风险，在一些开发工具商店中没有Project Lombok支持选择。 IDE和JDK升级存在破裂的风险，并且围绕项目的目标和实施存在争议。 常用注解： @Setter ：注解在类或字段，注解在类时为所有字段生成setter方法，注解在字段上时只为该字段生成setter方法。 @Getter ：使用方法同上，区别在于生成的是getter方法。 @ToString ：注解在类，添加toString方法。 @EqualsAndHashCode： 注解在类，生成hashCode和equals方法。 @NoArgsConstructor： 注解在类，生成无参的构造方法。 @RequiredArgsConstructor： 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。 @AllArgsConstructor： 注解在类，生成包含类中所有字段的构造方法。 @Data： 注解在类，生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。 @Slf4j： 注解在类，生成log变量，严格意义来说是常量。 简单来说就是减少了代码量 如实体类getter setter toString 等方法的编写 首先在idea安装lombok插件 不会的自行搜索idea安装lombok插件 接着在springboot项目pom文件加入 lombok插件 org.projectlombok lombok 1.18.10 true 接着编写实体类加上@Date注解 package com.boot.boot_resoure.entity; import lombok.Data; /** * @author : kaifa * create at: 2019-10-16 16:57 * @description: springboot2.x集成lombok * 不需要写get set方法插件会为我们自动生成减少了代码量 需要在idea安装lombok插件 * @Date包含 * @Getter * @Setter * @ToString * @EqualsAndHashCode * 这些注解 */ @Data public class User { private String name; private String password; } 此时看idea显示 方法自动生成了 接着编写测试controller package com.boot.boot_resoure.controller; import com.boot.boot_resoure.entity.User; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @author : kaifa * create at: 2019-10-16 17:02 * @description: lombok测试 */ @RestController @RequestMapping(\"lombok\") public class LombokController { /** * 测试lombok方法 * @return */ @GetMapping(\"/testLombok.html\") public String testLombok(){ //实体类没有写setter getter方法 还有toString方法 //都是lombok自动为我们创建的 User user = new User(); user.setName(\"name\"); user.setPassword(\"123456\"); return \"lombok:---\"+user.toString(); } } 启动项目访问 这里我把端口改为7001了因为端口冲突问题 http://localhost:7001/lombok/testLombok.html 得出结果: 下一章:springboot使用banner Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-10-22 18:08:34 "},"banner/banner.html":{"url":"banner/banner.html","title":"springboot使用banner","keywords":"","body":"springboot定制banner 什么是banner (项目地址:https://github.com/heng1234/springboot2.x/tree/master/boot_banner_yml) springboot启动的时候出现的这个文案就是banner . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.2.0.RELEASE) SpringBoot 有一个接口 org.springframework.boot.Banner 是专门来做这个操作的。我们可以实现这个接口来自定义打印 Banner 信息； org.springframework.boot.ResourceBanner 文本格式，SpringBoot 会读取配置项banner.txt和banner.location，从配置项中获取真实的文件地址；如果配置中没有配置，会把配置项作为文件去加载； org.springframework.boot.ImageBanner 图片格式，SpringBoot 加载配置项banner.image.location，从配置项中获取真实的路径，SpringBoot 会根据配置项的路径加载文件。 如果没有配置banner.image.location，转而依次加载banner.gif、banner.jpg、 banner.png这三个中存在的文件； 如果上面两种都没有配置，SpringBoot 就会加载默认的 Banner； 官网介绍: 以通过将banner.txt文件添加到类路径或将spring.banner.location属性设置为此类文件的位置来更改启动时打印的横幅。如果文件的编码不是UTF-8，则可以设置spring.banner.charset。除了一个文本文件，你还可以添加一个banner.gif，banner.jpg或banner.png图像文件到类路径或设置spring.banner.image.location属性。图像将转换为ASCII艺术作品并打印在任何文字横幅上方。 在banner.txt文件内部，可以使用以下任意占位符： 变量 描述 ${application.version} 您的应用程序的版本号，如中所述MANIFEST.MF。例如，Implementation-Version: 1.0打印为1.0。 ${application.formatted-version} 您的应用程序的版本号，已声明MANIFEST.MF并进行了格式显示（用括号括起来，并带有前缀v）。例如(v1.0)。 ${spring-boot.version} 您正在使用的Spring Boot版本。例如2.2.1.BUILD-SNAPSHOT。 ${spring-boot.formatted-version} 您正在使用的Spring Boot版本，其格式用于显示（用括号括起来，并带有前缀v）。例如(v2.2.1.BUILD-SNAPSHOT)。 ${Ansi.NAME}（或${AnsiColor.NAME}，${AnsiBackground.NAME}，${AnsiStyle.NAME}） NAMEANSI转义代码的名称在哪里。有关AnsiPropertySource详细信息，请参见。 ${application.title} 您的应用程序的标题，如中所述MANIFEST.MF。例如Implementation-Title: MyApp打印为MyApp。 SpringApplication.setBanner(…)如果要以编程方式生成横幅，则可以使用 该方法。使用该org.springframework.boot.Banner接口并实现您自己的printBanner()方法。 您还可以使用该spring.main.banner-mode属性来确定横幅是否必须在System.out（console）上打印，发送到配置的记录器（log）或根本不制作（off）。 打印的横幅注册为下以下名称的单例的bean： springBootBanner。 开始使用 首先在resource下创建一个banner.txt文件 里面内容填写: ${AnsiColor.BRIGHT_YELLOW} ${application.version} ${application.formatted-version} ${spring-boot.version} ${spring-boot.formatted-version} //////////////////////////////////////////////////////////////////// // _ooOoo_ // // o8888888o // // 88\" . \"88 // // (| ^_^ |) // // O\\ = /O // // ____/`---'\\____ // // .' \\\\| |// `. // // / \\\\||| : |||// \\ // // / _||||| -:- |||||- \\ // // | | \\\\\\ - /// | | // // | \\_| ''\\---/'' | | // // \\ .-\\__ `-` ___/-. / // // ___`. .' /--.--\\ `. . ___ // // .\"\" '_/___.' >'\"\". // // | | : `- \\`.;`\\ _ /`;.`/ - ` : | | // // \\ \\ `-. \\_ __\\ /__ _/ .-` / / // // ========`-.____`-.___\\_____/___.-`____.-'======== // // `=---=' // // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ // // 佛祖保佑 永不宕机 永无BUG 　　// //////////////////////////////////////////////////////////////////// 然后启动springboot就会出现 banner在线生成地址 SpringBoot 图片 Banner 定制 图片的 banner 支持 gif 、png、jpeg 格式的图片。使用的时候，选用合适的图片，然后将图片名字改成 banner，然后和文字的 banner.txt 文件一样，放到 resource ，目录下即可。 例如，我们将一个如下的 jpeg 格式的微博 logo 改名为 banner.jpg 文件放到 resource 目录下 启动显示 可自定义SpringApplication 如果SpringApplication默认设置不符合您的喜好，则可以创建一个本地实例并对其进行自定义。例如，要关闭横幅，您可以编写： public static void main(String[] args) { SpringApplication app = new SpringApplication(MySpringConfiguration.class); app.setBannerMode(Banner.Mode.OFF); app.run(args); } 下一章:springboot读取配置文件 Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-10-22 18:36:49 "},"banner/pro.html":{"url":"banner/pro.html","title":"springboot读取配置文件","keywords":"","body":"springboot读取配置文件 前言 (项目地址:https://github.com/heng1234/springboot2.x/tree/master/boot_banner_yml) Spring-Boot的核心配置文件是application.properties ，会默认读取该配置文件，当然也可以通过注解自定义配置文件的信息。 为什要这样读取 开发中，经常会有一些常量，变动较少，但是我们不能在java代码中写死，这样每次修改都得去java代码中修改，引用地方较多时我们需要修改很多java文件；所以我们可以集中写在某个配置文件中，这样只用修改配置文件就好 读取方法一 使用@value注解读取 首先application.yml文件里写入需要读取的数据 lv: name: hlvy password: 123456 User类 import lombok.Data; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import java.io.Serializable; /** * @author : kaifa * create at: 2019-10-18 14:36 * @description: springboot读取配置文件信息 */ //lombok @Data @Component public class User implements Serializable { @Value(\"${lv.name}\") private String name; @Value(\"${lv.password}\") private String password; } 测试controller类 package com.boot.boot_banner_yml.controller; import com.boot.boot_banner_yml.profile.Account; import com.boot.boot_banner_yml.profile.Text; import com.boot.boot_banner_yml.profile.User; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @author : kaifa * create at: 2019-10-18 14:47 * @description: 测试读取配置文件 */ @RestController @RequestMapping(\"test\") public class TestController { @Autowired private User user; /** * @Value 读取application.yml数据 * @return */ @RequestMapping(\"user\") public User readFileUser(){ return user; } } 访问http://localhost:7002/test/user.do 显示 方法二使用前缀读取 创建Account类 package com.boot.boot_banner_yml.profile; import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; import java.io.Serializable; /** * @author : kaifa * create at: 2019-10-18 14:36 * @description: springboot读取配置文件信息 */ //配置文件前缀 @ConfigurationProperties(prefix=\"lv\") @Component //lombok @Data public class Account implements Serializable { /** * 这里不需要写@value注解了 这里的名字与配置文件一致 */ private String name; private String password; } controller测试 @Autowired private Account account; /** * 读取application.yml数据 * 读取前缀 * @return */ @RequestMapping(\"account\") public Account readFileAccount(){ return account; } 访问http://localhost:7002/test/account.do 显示 方法三使用自定义properties文件读取 首先在resources创建 val.properties val.text= 测试自定义文件数据读取 然后创建Text类 import lombok.Data; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.PropertySource; import org.springframework.stereotype.Component; import java.io.Serializable; /** * @author : kaifa * create at: 2019-10-18 14:36 * @description: springboot读取配置文件信息 */ //配置文件前缀 @ConfigurationProperties(prefix=\"val\") // 获取外部的配置文件文件,需要指定配置文件的路径 @PropertySource( value = \"classpath:val.properties\", encoding = \"utf-8\" ) @Component //lombok @Data public class Text implements Serializable { /** * 这里不需要写@value注解了 这里的名字与配置文件一致 */ private String text; } controller测试 @Autowired private Text text; /** * 自定义val.yml读取文件 * @return */ @RequestMapping(\"text\") public Text readFileText(){ return text; } 访问http://localhost:7002/test/text.do 显示 下一章:springboot访问路径配置和Profile配置说明 Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-10-22 18:37:25 "},"banner/webmvc.html":{"url":"banner/webmvc.html","title":"springboot访问路径配置和Profile配置说明","keywords":"","body":"springboot访问路径配置和Profile配置说明 Spring Boot匹配指定后缀.action .do的路径访问 (项目地址:https://github.com/heng1234/springboot2.x/tree/master/boot_banner_yml) 新建个配置文件MyWebMvcConfigurer import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.DispatcherServlet; import org.springframework.web.servlet.config.annotation.PathMatchConfigurer; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; /** * @author : kaifa * create at: 2019-10-18 17:07 * @description: WebMvcConfigurer配置类 */ @Configuration public class MyWebMvcConfigurer implements WebMvcConfigurer { @Override public void configurePathMatch(PathMatchConfigurer configurer) { //开启路径后缀匹配 configurer.setUseRegisteredSuffixPatternMatch(true); } /** * 设置匹配*.action后缀请求 * @param dispatcherServlet * @return */ @Bean public ServletRegistrationBean servletRegistrationBean(DispatcherServlet dispatcherServlet) { ServletRegistrationBean servletServletRegistrationBean = new ServletRegistrationBean<>(dispatcherServlet); servletServletRegistrationBean.addUrlMappings(\"*.action\",\"*.do\"); return servletServletRegistrationBean; } } 只有后缀是.action 和.do的才能访问controller到 Profile配置 Profile用来针对不同的环境下使用不同的配置文件，多环境配置文件必须以application-{profile}.properties的格式命，其中{profile}为环境标识。比如定义两个配置文件： application-dev.properties：开发环境 server.port=8080 application-prod.properties：生产环境 server.port=8081 至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。 如：spring.profiles.active=dev就会加载application-dev.properties配置文件内容。可以在运行jar文件的时候使用命令java -jar xxx.jar --spring.profiles.active={profile}切换不同的环境配置。 下一章:pringboot2.x集成mybatis(druid+xml方式) Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-10-22 18:38:51 "},"mybatis/mybatis.html":{"url":"mybatis/mybatis.html","title":"springboot集成mybatis(xml形式)","keywords":"","body":"Springboot2.x集成mybatis(druid+xml方式) 项目地址:https://github.com/heng1234/springboot2.x/tree/master/boot_mybatis 整合MyBatis之前，先搭建一个基本的Spring Boot项目项目创建地址。这里使用关系型数据库Oracle 11g 创建数据表t_user CREATE TABLE \"T_USER\" ( \"ID\" NUMBER(20,0) NOT NULL ENABLE, \"USERNAME\" VARCHAR2(50), \"PASSWORD\" VARCHAR2(50), \"CREATE_TIME\" DATE ) SEGMENT CREATION IMMEDIATE PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645 PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) TABLESPACE \"SYSTEM\" INSERT INTO \"BOOT\".\"user\"(\"ID\", \"USERNAME\", \"PASSWORD\", \"CREATE_TIME\") VALUES ('1', 'loren', '123456', TO_DATE('2019-10-22 09:38:29', 'SYYYY-MM-DD HH24:MI:SS')); INSERT INTO \"BOOT\".\"user\"(\"ID\", \"USERNAME\", \"PASSWORD\", \"CREATE_TIME\") VALUES ('2', 'hlvy', '123456', TO_DATE('2019-10-22 09:38:48', 'SYYYY-MM-DD HH24:MI:SS')); Pom.xml文件引入jar com.oracle ojdbc6 11.2.0.4 com.alibaba druid-spring-boot-starter 1.1.10 org.projectlombok lombok 1.18.10 true 集成druid application.yml配置 server: port: 7003 spring: datasource: druid: # 数据库访问配置, 使用druid数据源 # 数据源 oracle type: com.alibaba.druid.pool.DruidDataSource driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@localhost:49161:XE username: boot password: 123456 # 连接池配置 initial-size: 5 min-idle: 5 max-active: 20 # 连接等待超时时间 max-wait: 30000 # 配置检测可以关闭的空闲连接间隔时间 time-between-eviction-runs-millis: 60000 # 配置连接在池中的最小生存时间 min-evictable-idle-time-millis: 300000 validation-query: select '1' from dual test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并且指定每个连接上PSCache的大小 pool-prepared-statements: true max-open-prepared-statements: 20 max-pool-prepared-statement-per-connection-size: 20 # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, 'wall'用于防火墙 filters: stat,wall # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔 aop-patterns: com.boot.boot_mybatis.service.* # WebStatFilter配置 web-stat-filter: enabled: true # 添加过滤规则 url-pattern: /* # 忽略过滤的格式 exclusions: '*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*' # StatViewServlet配置 stat-view-servlet: enabled: true # 访问路径为/druid时，跳转到StatViewServlet url-pattern: /druid/* # 是否能够重置数据 reset-enable: false # 需要账号密码才能访问控制台 login-username: druid login-password: 123456 # IP白名单 # allow: 127.0.0.1 #　IP黑名单（共同存在时，deny优先于allow） # deny: 192.168.1.218 # 配置StatFilter filter: stat: log-slow-sql: true #showSql logging: level: com: boot: boot_mybatis: mapper: debug 启动项目访问http://localhost:7003/druid/login.html 出现 用户名密码是配置文件配置的 用户名 druid 密码123456 登录进来会看到这个页面 集成mybatis pom文件引入xmyabtis包 org.mybatis.spring.boot mybatis-spring-boot-starter 1.3.1 创建 entity mapper controller service 以及resource创建mapper存储mapper xml文件 项目结构 application.yml加入 mybatis: #扫描mapper xml mapper-locations: classpath:mapper/*.xml #扫描实体类 type-aliases-package: com.boot.boot_mybatis.entity 创建MybatisConfig用于扫描mapper接口 import org.mybatis.spring.annotation.MapperScan; import org.springframework.context.annotation.Configuration; /** * @author : kaifa * create at: 2019-10-22 10:03 * @description: mybatis配置类 */ @Configuration @MapperScan(\"com.boot.boot_mybatis.mapper\") public class MybatisConfig { } UserMapper.xml select id,username,password,create_time createTime from t_user UserMapper import com.boot.boot_mybatis.entity.User; import java.util.List; /** * @author : kaifa * create at: 2019-10-22 10:10 * @description: user mapper接口 */ public interface UserMapper { /**查询所有用户*/ List selectListAll(); } UserService import com.boot.boot_mybatis.entity.User; import com.boot.boot_mybatis.mapper.UserMapper; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; /** * @author : kaifa * create at: 2019-10-22 10:10 * @description: user 业务层 */ @Service public class UserService { @Autowired private UserMapper userMapper; /** * 查询所有用户 * @return */ public List selectListAll(){ return userMapper.selectListAll(); } } controller import com.boot.boot_mybatis.entity.User; import com.boot.boot_mybatis.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.List; /** * @author : kaifa * create at: 2019-10-22 10:16 * @description: user controller */ @RestController @RequestMapping(\"user\") public class UserController { @Autowired private UserService userService; /** * 查询所有用户 * @return */ @RequestMapping(\"userList.do\") List selectListAll(){ return userService.selectListAll(); } } 浏览器访问http://localhost:7003/user/userList.do 查看druid监控 下一章:Spring Boot 2.x AOP记录用户操作日志 Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-10-22 18:42:31 "},"Aop/aop.html":{"url":"Aop/aop.html","title":"springboot  AOP记录用户操作日志","keywords":"","body":"Spring Boot 2.x AOP记录用户操作日志 项目地址:https://github.com/heng1234/springboot2.x/tree/master/boot_log_aop springboot使用AOP配合自定义注解可以方便的实现用户操作的监控 首先pom文件加入jar com.alibaba druid-spring-boot-starter 1.1.10 org.projectlombok lombok 1.18.10 true org.mybatis.spring.boot mybatis-spring-boot-starter 1.3.1 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-aop 2.1.7.RELEASE com.oracle ojdbc6 11.2.0.4 创建数据库表这里使用的是oracle11g CREATE TABLE \"SYS_LOG\" ( \"ID\" NUMBER(20) NOT NULL , \"USERNAME\" VARCHAR2(50 BYTE) NULL , \"OPERATION\" VARCHAR2(50 BYTE) NULL , \"TIME\" NUMBER(11) NULL , \"METHOD\" VARCHAR2(200 BYTE) NULL , \"PARAMS\" VARCHAR2(500 BYTE) NULL , \"IP\" VARCHAR2(64 BYTE) NULL , \"CREATE_TIME\" DATE NULL ); COMMENT ON COLUMN \"SYS_LOG\".\"USERNAME\" IS '用户名'; COMMENT ON COLUMN \"SYS_LOG\".\"OPERATION\" IS '用户操作'; COMMENT ON COLUMN \"SYS_LOG\".\"TIME\" IS '响应时间'; COMMENT ON COLUMN \"SYS_LOG\".\"METHOD\" IS '请求方法'; COMMENT ON COLUMN \"SYS_LOG\".\"PARAMS\" IS '请求参数'; COMMENT ON COLUMN \"SYS_LOG\".\"IP\" IS 'IP地址'; COMMENT ON COLUMN \"SYS_LOG\".\"CREATE_TIME\" IS '创建时间'; CREATE SEQUENCE seq_sys_log START WITH 1 INCREMENT BY 1; 对应的实体类 import lombok.Data; import java.io.Serializable; import java.util.Date; @Data public class SysLog implements Serializable{ private static final long serialVersionUID = -6309732882044872298L; /** * id */ private Integer id; /** * 用户名 */ private String username; /** * 用户操作 */ private String operation; /** * 响应时间 */ private Integer time; /** * 请求方法 */ private String method; /** * 请求参数 */ private String params; /** * Ip地址 */ private String ip; /** * 创建时间 */ private Date createTime; } 定义注解@Log注解 package com.boot.boot_log_aop.annotation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Retention(value = RetentionPolicy.RUNTIME) @Target(value = ElementType.METHOD) public @interface Log { String value() default \"\"; } mapper import com.boot.boot_log_aop.entity.SysLog; /** * @author : kaifa * create at: 2019-10-22 17:30 * @description: log mapper接口 */ public interface LogMapper { /** * 切面保存日志 * @param sysLog * @return */ public int saveLog(SysLog sysLog); } Mapper.xml INSERT INTO SYS_LOG(ID,USERNAME,OPERATION,TIME,METHOD,PARAMS,IP,CREATE_TIME) VALUES (seq_sys_log.nextval, #{username}, #{operation}, #{time}, #{method}, #{params}, #{ip}, #{createTime}) 定义一个LogAspect类，使用@Aspect标注让其成为一个切面，切点为使用@Log注解标注的方法，使用@Around环绕通知 /** * @author : kaifa * create at: 2019-10-22 17:19 * @description: log 切面 */ @Component @Aspect public class LogAspect { @Autowired private LogMapper logMapper; @Pointcut(\"@annotation(com.boot.boot_log_aop.annotation.Log)\") public void pointcut(){ } /** * 要有返回值,不然执行的方法返回为空 * @param point * @return */ @Around(\"pointcut()\") public Object around(ProceedingJoinPoint point){ Object obj = null; // Object[] args = point.getArgs(); long beginTime = System.currentTimeMillis(); try { // 执行方法 obj = point.proceed(); } catch (Throwable e) { e.printStackTrace(); } // 执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; // 保存日志 saveLog(point, time); return obj; } private void saveLog(ProceedingJoinPoint joinPoint, long time) { MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); SysLog sysLog = new SysLog(); Log logAnnotation = method.getAnnotation(Log.class); if (logAnnotation != null) { // 注解上的描述 sysLog.setOperation(logAnnotation.value()); } // 请求的方法名 String className = joinPoint.getTarget().getClass().getName(); String methodName = signature.getName(); sysLog.setMethod(className + \".\" + methodName + \"()\"); // 请求的方法参数值 Object[] args = joinPoint.getArgs(); // 请求的方法参数名称 LocalVariableTableParameterNameDiscoverer u = new LocalVariableTableParameterNameDiscoverer(); String[] paramNames = u.getParameterNames(method); if (args != null && paramNames != null) { String params = \"\"; for (int i = 0; i 测试 import javax.servlet.http.HttpServletRequest; /** * @author : kaifa * create at: 2019-10-22 17:33 * @description: 测试日志切面controller */ @RestController @RequestMapping(\"log\") public class LogController { @RequestMapping(\"findlog\") @Log(\"hello log\") public String log1(HttpServletRequest request){ return \"hello log\"; } @Log(\"测试log\") @RequestMapping(\"findlogId\") public String log2(HttpServletRequest request,String name){ return \"hello \"+name; } } 项目结构: 启动项目，分别访问 http://localhost:7004/log/findlog http://localhost:7004/log/findlogId?name=111 查询数据库 下一章:Spring Boot 使用thymeleaf Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-10-23 18:46:50 "},"thymeleaf/tf.html":{"url":"thymeleaf/tf.html","title":"Spring Boot 使用thymeleaf","keywords":"","body":"SpringBoot整合Thymeleaf 项目地址：https://github.com/heng1234/springboot2.x/commit/25bbc2433c6f5953575d22d3179383bf7273d82d 语法参考:springboot整合thymeleaf及常用标签的使用方法 常用模板引擎对比 模板引擎 优点 缺点 jsp 1、功能强大，可以写java代码 2、支持jsp标签（jsp tag） 3、支持表达式语言（el） 4、官方标准，用户群广，丰富的第三方jsp标签库 5、性能良好。jsp编译成class文件执行，有很好的性能表现 动态资源和静态资源全部耦合在一起，必须要在支持java的web服务器里运行（例如tomcat，jetty，resin等）服务器压力大 FreeMarker 1、不能编写java代码，可以实现严格的mvc分离 2、性能非常不错 3、对jsp标签支持良好 4、内置大量常用功能，使用非常方便 5、宏定义（类似jsp标签）非常方便 6、使用表达式语言 1、不是官方标准 2、用户群体和第三方标签库没有jsp多 Thymeleaf 静态html嵌入标签属性，浏览器可以直接打开模板文件，便于前后端联调。springboot官方推荐方案。 模板必须符合xml规范 SpringBoot整合Themeleaf pom org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web org.projectlombok lombok true net.sourceforge.nekohtml nekohtml 1.9.22 application.properties server.port=7004 #开启模板缓存（默认值：true） #开发时关闭缓存,不然没法看到实时页面 spring.thymeleaf.cache=false #Check that the template exists before rendering it. spring.thymeleaf.check-template=true #检查模板位置是否正确（默认值:true） spring.thymeleaf.check-template-location=true #Content-Type的值（默认值：text/html） spring.thymeleaf.servlet.content-type=text/html #开启MVC Thymeleaf视图解析（默认值：true） spring.thymeleaf.enabled=true #模板编码 spring.thymeleaf.encoding=UTF-8 #要被排除在解析之外的视图名称列表，用逗号分隔 spring.thymeleaf.excluded-view-names= #要运用于模板之上的模板模式。另见StandardTemplate-ModeHandlers(默认值：HTML5) # 用非严格的 HTML spring.thymeleaf.mode=HTML5 #在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/） spring.thymeleaf.prefix=classpath:/templates/ #在构建URL时添加到视图名称后的后缀（默认值：.html） spring.thymeleaf.suffix=.html #Thymeleaf模板解析器在解析器链中的顺序。默认情况下，它排第一位。顺序从1开始，只有在定义了额外的TemplateResolver Bean时才需要设置这个属性。 #spring.thymeleaf.template-resolver-order= #可解析的视图名称列表，用逗号分隔 #spring.thymeleaf.view-names= #spring.mvc.view.prefix=/ #spring.mvc.view.suffix=.html Controller import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.HttpServletRequest; /** * @author : kaifa * create at: 2019-10-23 13:55 * @description: thymeleaf 控制层 */ @Controller @RequestMapping(\"tf\") public class ThyeleafController { @RequestMapping(\"index.do\") public String toIndex(HttpServletRequest request, String name, Model model){ model.addAttribute(\"name\",name); model.addAttribute(\"href\",\"https://blog.csdn.net/qq_39313596/article/details/82147626\"); return \"index\"; } } templates新建index.html 这可以省略--> Title thymeleaf教程地址: name: 访问http://localhost:7004/tf/index.do?name=hlvy 下一章: SpringBoot整合Thymeleaf——自定义标签 Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-10-24 17:18:41 "},"thymeleaf/customizetf.html":{"url":"thymeleaf/customizetf.html","title":"SpringBoot整合Thymeleaf——自定义标签","keywords":"","body":"SpringBoot整合Thymeleaf——自定义标签 项目地址: https://github.com/heng1234/springboot2.x/tree/master/boot_thymeleaf 基于上一章节springBoot整合Thymeleaf thymeleaf 丰富的扩展性为我们实现自定义的标签实现了可能。这里以创建数据脱敏标签这个需求为例，讲解下如何实现自定义的dialect。 需求描述： controller的model中我们有客户的手机号信息：\"phone\": \"11111111111\"。 按照默认的写法，要在页面中展示手机号，HTML模板为： 如果不使用自定义dialect，这里会将完整的手机号展示出来： 11111111111 接下来我们打算打造一个自定义方言： 实现如下的效果： 11*******11 除了首位2个字符全部替换为星号是自定义dialect的默认行为。除此之外，我们还可以使用正则表达式来定义替换规则。比如，除了前两个字符，其余的全替换为星号： 实现自定义标签处理器 对于Thymeleaf方言，自定义标签的处理逻辑是在标签处理器定义的。 自定义标签处理器需要实现AbstractAttributeTagProcessor 接口，标签的处理逻辑在doProcess 方法中编写。 数据脱敏标签的处理器代码如下所示： ThSysTagProcessor import org.thymeleaf.IEngineConfiguration; import org.thymeleaf.context.ITemplateContext; import org.thymeleaf.engine.AttributeName; import org.thymeleaf.model.IAttribute; import org.thymeleaf.model.IProcessableElementTag; import org.thymeleaf.processor.element.AbstractAttributeTagProcessor; import org.thymeleaf.processor.element.IElementTagStructureHandler; import org.thymeleaf.standard.expression.IStandardExpression; import org.thymeleaf.standard.expression.IStandardExpressionParser; import org.thymeleaf.standard.expression.StandardExpressions; import org.thymeleaf.templatemode.TemplateMode; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * @author : kaifa * create at: 2019-10-24 15:53 * @description: 自定义tf标签配置类 */ public class ThSysTagProcessor extends AbstractAttributeTagProcessor { private static final String TEXT_ATTRIBUTE = \"text\"; private static final int PRECEDENCE = 10000; private static final String PATTERN_ATTRIBUTE = \"pattern\"; private static final String DEFAULT_PATTERN = \"^.{2}(.*).{2}$\"; /** templateMode: 模板模式，这里使用HTML模板。 dialectPrefix: 标签前缀。即xxx:text中的xxx。在此例子中prefix为thSys。 elementName：匹配标签元素名。举例来说如果是div，则我们的自定义标签只能用在div标签中。为null能够匹配所有的标签。 prefixElementName: 标签名是否要求前缀。 attributeName: 自定义标签属性名。这里为text。 prefixAttributeName：属性名是否要求前缀，如果为true，Thymeeleaf会要求使用text属性时必须加上前缀，即thSys:text。 precedence：标签处理的优先级，此处使用和Thymeleaf标准方言相同的优先级。 removeAttribute：标签处理后是否移除自定义属性。*/ public ThSysTagProcessor( String dialectPrefix) { // 方言名称，前缀，处理优先级 super(TemplateMode.HTML, dialectPrefix, null, false, TEXT_ATTRIBUTE, true, PRECEDENCE, true); } @Override protected void doProcess(ITemplateContext iTemplateContext, IProcessableElementTag iProcessableElementTag, AttributeName attributeName, String s, IElementTagStructureHandler iElementTagStructureHandler) { //s为自定义属性text的内容，如果s为表达式，该函数可以获取表达式的值 final Object value = getExpressionValue(iTemplateContext, s); IAttribute patternAttribute = iProcessableElementTag.getAttribute(PATTERN_ATTRIBUTE); if (null == patternAttribute) { // 设置标签的内容 iElementTagStructureHandler.setBody(doMasking(value.toString(), DEFAULT_PATTERN), false); } else { String patternValue = iProcessableElementTag.getAttribute(PATTERN_ATTRIBUTE).getValue(); iElementTagStructureHandler.setBody(doMasking(value.toString(), patternValue), false); } } private static String doMasking(String target, String patternString) { Pattern pattern = Pattern.compile(patternString); Matcher matcher = pattern.matcher(target); if (matcher.matches()) { if (matcher.groupCount() 定义方言类 编写好之定义标签的处理器之后，别忘了定义一个方言类。在方言类中，我们需要给出方言的名称，前缀，处理优先级和涉及到的一系列自定义标签处理器。代码如下所示： ThSysTagProcessor import org.thymeleaf.dialect.AbstractProcessorDialect; import org.thymeleaf.processor.IProcessor; import org.thymeleaf.standard.StandardDialect; import java.util.HashSet; import java.util.Set; /** * @author : kaifa * create at: 2019-10-24 16:07 * @description: 定义方言类 */ public class ThSysDialect extends AbstractProcessorDialect { private static final String PREFIX = \"hlvy\"; public ThSysDialect() { // 方言名称，前缀，处理优先级 super(\"Tf Hlvy\", \"hlvy\", StandardDialect.PROCESSOR_PRECEDENCE); } @Override public Set getProcessors(String s) { // 把所有的自定义tag处理器加入处理器集，这个例子中我们只有这一个自定义处理器 final Set processorSet = new HashSet<>(); ThSysTagProcessor thSysTagProcessor = new ThSysTagProcessor(PREFIX); processorSet.add(thSysTagProcessor); return processorSet; } } 注册bean TfConfig /** * @author : kaifa * create at: 2019-10-24 16:11 * @description: tf bean */ @Configuration public class TfConfig { @Bean public ThSysDialect thSysDialect() { return new ThSysDialect(); } } Controller @RequestMapping(\"phone.do\") public String toPhone(HttpServletRequest request, String phone, Model model){ model.addAttribute(\"phone\",phone); return \"phone\"; } Phone.html 这可以省略--> Title 自定义标签 phone: 测试 http://localhost:7004/tf/phone.do?phone=18616283921 下一章: Spring Boot MyBatis配置Druid多数据源 Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-10-28 11:35:23 "},"datasource/datasource.html":{"url":"datasource/datasource.html","title":"Spring Boot MyBatis配置Druid多数据源","keywords":"","body":"Spring Boot MyBatis配置Druid多数据源 项目地址:https://github.com/heng1234/springboot2.x/tree/master/boot_mult_datasource 在实际场景中，会遇到不同用户拥有不同的数据源，这些数据源信息配置在数据库表里面，需要我们根据用户切换成相应的数据源。会介绍如何在SpringBoot + Mybatis中配置多数据源 数据库 mysql： CREATE TABLE `student` ( `SNO` varchar(3) NOT NULL, `SNAME` varchar(9) NOT NULL, `SSEX` char(2) NOT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 数据mysql： INSERT INTO `txlcn-demo`.`student`(`SNO`, `SNAME`, `SSEX`) VALUES ('001', 'KangKang', 'M'); INSERT INTO `txlcn-demo`.`student`(`SNO`, `SNAME`, `SSEX`) VALUES ('002', 'Mike', 'M'); INSERT INTO `txlcn-demo`.`student`(`SNO`, `SNAME`, `SSEX`) VALUES ('003', 'Jane', 'F'); 数据库 oracle: CREATE TABLE \"BOOT\".\"STUDENT\" ( \"SNO\" VARCHAR2(3) NOT NULL ENABLE, \"SNAME\" VARCHAR2(9) NOT NULL ENABLE, \"SSEX\" CHAR(2) NOT NULL ENABLE, \"DATASOURCE\" VARCHAR2(10), CHECK (SNO IS NOT NULL) ENABLE, CHECK (SNAME IS NOT NULL) ENABLE, CHECK (SSEX IS NOT NULL) ENABLE ) SEGMENT CREATION IMMEDIATE PCTFREE 10 PCTUSED 40 INITRANS 1 MAXTRANS 255 NOCOMPRESS LOGGING STORAGE(INITIAL 65536 NEXT 1048576 MINEXTENTS 1 MAXEXTENTS 2147483645 PCTINCREASE 0 FREELISTS 1 FREELIST GROUPS 1 BUFFER_POOL DEFAULT FLASH_CACHE DEFAULT CELL_FLASH_CACHE DEFAULT) TABLESPACE \"SYSTEM\" 数据 oracle: INSERT INTO \"BOOT\".\"STUDENT\"(\"SNO\", \"SNAME\", \"SSEX\", \"DATASOURCE\") VALUES ('001', 'KangKang', 'M ', 'oracle'); INSERT INTO \"BOOT\".\"STUDENT\"(\"SNO\", \"SNAME\", \"SSEX\", \"DATASOURCE\") VALUES ('002', 'Mike', 'M ', 'oracle'); INSERT INTO \"BOOT\".\"STUDENT\"(\"SNO\", \"SNAME\", \"SSEX\", \"DATASOURCE\") VALUES ('003', 'Jane', 'F ', 'oracle'); INSERT INTO \"BOOT\".\"STUDENT\"(\"SNO\", \"SNAME\", \"SSEX\", \"DATASOURCE\") VALUES ('004', 'Maria', 'F ', 'oracle'); pom文件引入jar com.oracle ojdbc6 11.2.0.4 com.alibaba druid-spring-boot-starter 1.1.10 org.mybatis.spring.boot mybatis-spring-boot-starter 1.3.1 org.projectlombok lombok 1.18.10 true mysql mysql-connector-java application.yml中配置多数据源 server: port: 7005 spring: datasource: druid: # 数据库访问配置, 使用druid数据源 # 数据源1 mysql mysql: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://121.40.179.66:3306/txlcn-demo?characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowMultiQueries=true&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=Asia/Shanghai username: root password: b9b8-4231-8b38-c395269a93be # 数据源2 oracle oracle: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: oracle.jdbc.driver.OracleDriver url: jdbc:oracle:thin:@localhost:49161:XE username: boot password: 123456 # 连接池配置 initial-size: 5 min-idle: 5 max-active: 20 # 连接等待超时时间 max-wait: 30000 # 配置检测可以关闭的空闲连接间隔时间 time-between-eviction-runs-millis: 60000 # 配置连接在池中的最小生存时间 min-evictable-idle-time-millis: 300000 validation-query: select '1' from dual test-while-idle: true test-on-borrow: false test-on-return: false # 打开PSCache，并且指定每个连接上PSCache的大小 pool-prepared-statements: true max-open-prepared-statements: 20 max-pool-prepared-statement-per-connection-size: 20 # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, 'wall'用于防火墙 filters: stat,wall # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔 aop-patterns: com.springboot.servie.* # WebStatFilter配置 web-stat-filter: enabled: true # 添加过滤规则 url-pattern: /* # 忽略过滤的格式 exclusions: '*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*' # StatViewServlet配置 stat-view-servlet: enabled: true # 访问路径为/druid时，跳转到StatViewServlet url-pattern: /druid/* # 是否能够重置数据 reset-enable: false # 需要账号密码才能访问控制台 login-username: druid login-password: druid123 # IP白名单 # allow: 127.0.0.1 #　IP黑名单（共同存在时，deny优先于allow） # deny: 192.168.1.218 # 配置StatFilter filter: stat: log-slow-sql: true 创建两个数据源配置类MysqlDatasourceConfig和OracleDatasourceConfig： MysqlDatasourceConfig： import com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder; import org.apache.ibatis.session.SqlSessionFactory; import org.mybatis.spring.SqlSessionFactoryBean; import org.mybatis.spring.annotation.MapperScan; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.core.io.support.PathMatchingResourcePatternResolver; import org.springframework.jdbc.datasource.DataSourceTransactionManager; import javax.sql.DataSource; /** * @author : kaifa * create at: 2019-10-24 17:46 * @description: 上面代码配置了一个名为mysqldatasource的数据源， * 对应application.yml中spring.datasource.druid.mysql前缀配置的数据库。 * 然后创建了一个名为mysqlSqlSessionFactory的Bean，并且注入了mysqldatasource。 * 与此同时，还分别定了两个扫描路径PACKAGE和MAPPER_LOCATION，前者为Mysql数据库对应的mapper接口地址， * 后者为对应的mapper xml文件路径。 @Primary标志这个Bean如果在多个同类Bean候选时，该Bean优先被考虑。 * 多数据源配置的时候，必须要有一个主数据源，用@Primary标志该Bean。 */ @Configuration @MapperScan(basePackages = MysqlDatasourceConfig.PACKAGE, sqlSessionFactoryRef = \"mysqlSqlSessionFactory\") public class MysqlDatasourceConfig { //mapper扫描路径 static final String PACKAGE = \"com.boot.boot_mult_datasource.mysql.mapper\"; // mybatis mapper xml扫描路径 static final String MAPPER_LOCATION = \"classpath:mysqlmapper/*.xml\"; @Primary @Bean(name = \"mysqldatasource\") @ConfigurationProperties(\"spring.datasource.druid.mysql\") public DataSource mysqlDataSource() { return DruidDataSourceBuilder.create().build(); } @Bean(name = \"mysqlTransactionManager\") @Primary public DataSourceTransactionManager mysqlTransactionManager() { return new DataSourceTransactionManager(mysqlDataSource()); } @Bean(name = \"mysqlSqlSessionFactory\") @Primary public SqlSessionFactory mysqlSqlSessionFactory(@Qualifier(\"mysqldatasource\") DataSource dataSource) throws Exception { final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); //如果不使用xml的方式配置mapper，则可以省去下面这行mapper location的配置。 sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(MysqlDatasourceConfig.MAPPER_LOCATION)); return sessionFactory.getObject(); } } OracleDatasourceConfig： import com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder; import org.apache.ibatis.session.SqlSessionFactory; import org.mybatis.spring.SqlSessionFactoryBean; import org.mybatis.spring.annotation.MapperScan; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.core.io.support.PathMatchingResourcePatternResolver; import org.springframework.jdbc.datasource.DataSourceTransactionManager; import javax.sql.DataSource; /** * @author : kaifa * create at: 2019-10-24 17:50 * @description: Oracle数据库对应的配置 */ @Configuration @MapperScan(basePackages = OracleDatasourceConfig.PACKAGE, sqlSessionFactoryRef = \"oracleSqlSessionFactory\") public class OracleDatasourceConfig { // oracledao扫描路径 static final String PACKAGE = \"com.boot.boot_mult_datasource.oracle.mapper\"; // mybatis mapper扫描路径 static final String MAPPER_LOCATION = \"classpath:oraclemapper/*.xml\"; @Bean(name = \"oracledatasource\") @ConfigurationProperties(\"spring.datasource.druid.oracle\") public DataSource oracleDataSource() { return DruidDataSourceBuilder.create().build(); } @Bean(name = \"oracleTransactionManager\") public DataSourceTransactionManager oracleTransactionManager() { return new DataSourceTransactionManager(oracleDataSource()); } @Bean(name = \"oracleSqlSessionFactory\") public SqlSessionFactory oracleSqlSessionFactory(@Qualifier(\"oracledatasource\") DataSource dataSource) throws Exception { final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); //如果不使用xml的方式配置mapper，则可以省去下面这行mapper location的配置。 sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(OracleDatasourceConfig.MAPPER_LOCATION)); return sessionFactory.getObject(); } } 测试 配置完多数据源，接下来分别在com.boot.boot_mult_datasource.mysql.mapper路径和com.boot.boot_mult_datasource.oracle.mapper路径下创建两个mapper接口： MysqlStudentMapper： import java.util.List; import java.util.Map; public interface MysqlStudentMapper { List> getAllStudents(); } OracleStudentMapper： import java.util.List; import java.util.Map; public interface OracleStudentMapper { List> getAllStudents(); } 接着创建mapper接口对应的实现： resources下的mysqlmapper创建 MysqlStudentMapper.xml： select * from student resources下的oraclemapper创建 OracleStudentMapper.xml： select * from student 项目结构: 访问：http://localhost:7005/student/querystudentsfrommysql 访问:http://localhost:7005/student/querystudentsfromoracle 下一章：SpringBoot 中使用Redis缓存 Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-10-28 17:25:04 "},"redis/redis.html":{"url":"redis/redis.html","title":"SpringBoot 中使用Redis缓存","keywords":"","body":"SpringBoot 中使用Redis缓存 在项目中对数据的访问往往都是直接访问数据库的方式，但如果对数据的访问量很大或者访问很频繁的话，将会对数据库来很大的压力，甚至造成数据库崩溃。为了解决这类问题redis数据库脱颖而出，redis数据库出现时是以非关系数据库的光环展示在广大程序猿的面前的，后来redis的迭代版本支持了缓存数据、登录session状态（分布式session共享）等。所以又被作为内存缓存的形式应用到大型企业级项目中。 1、Redis简单介绍 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value非关系性数据库(NoSql)。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 Redis可以存储键与5种不同数据结构类型之间的映射，这5种数据结构类型分别为 String（字符串）、List（列表）、Set（集合）、Hash（散列）和 Zset（有序集合）。 2.2 Redis 优势 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 2.3 Redis与其他key-value存储有什么不同？ Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。 Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。 添加Redis依赖包 在项目的pom.xml中添加如下： org.springframework.boot spring-boot-starter-data-redis application.yml： spring: #redis配置 redis: #redis密码 password: 123456 #Redis服务器地址 host: 127.0.0.1 #Redis服务器连接端口 port: 6379 #连接超时时间（毫秒） timeout: 5000 #Redis数据库索引（默认为0） database: 1 jedis: pool: #连接池最大连接数（使用负值表示没有限制） max-active: 50 #连接池最大阻塞等待时间（使用负值表示没有限制） max-wait: 3000 #连接池中的最大空闲连接 max-idle: 20 #连接池中的最小空闲连接 min-idle: 2 server: port: 7006 接着配置redis序列号等 RedisConfig： import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; /** * @author : hlvy * create at: 2019-10-14 11:33 * @description: redis配置类 */ @Configuration public class RedisConfig { @Bean @SuppressWarnings(\"all\") public RedisTemplate redisTemplate(RedisConnectionFactory factory) { RedisTemplate template = new RedisTemplate(); template.setConnectionFactory(factory); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; } } RedisUtil： import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Component; import org.springframework.util.CollectionUtils; import java.util.List; import java.util.Map; import java.util.Set; import java.util.concurrent.TimeUnit; /** * @author : kaifa * create at: -- : * @description: redis工具类 */ @Component public class RedisUtil { @Autowired private RedisTemplate redisTemplate; // =============================common============================ /** * 指定缓存失效时间 * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key, long time) { try { if (time > 0) { redisTemplate.expire(key, time, TimeUnit.SECONDS); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 根据key 获取过期时间 * @param key 键 不能为null * @return 时间(秒) 返回0代表为永久有效 */ public long getExpire(String key) { return redisTemplate.getExpire(key, TimeUnit.SECONDS); } /** * 判断key是否存在 * @param key 键 * @return true 存在 false不存在 */ public boolean hasKey(String key) { try { return redisTemplate.hasKey(key); } catch (Exception e) { e.printStackTrace(); return false; } } /** * 删除缓存 * @param key 可以传一个值 或多个 */ @SuppressWarnings(\"unchecked\") public void del(String... key) { if (key != null && key.length > 0) { if (key.length == 1) { redisTemplate.delete(key[0]); } else { redisTemplate.delete(CollectionUtils.arrayToList(key)); } } } // ============================String============================= /** * 普通缓存获取 * @param key 键 * @return 值 */ public Object get(String key) { return key == null ? null : redisTemplate.opsForValue().get(key); } /** * 普通缓存放入 * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key, Object value) { try { redisTemplate.opsForValue().set(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 普通缓存放入并设置时间 * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean set(String key, Object value, long time) { try { if (time > 0) { redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); } else { set(key, value); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 递增 * @param key 键 * @param delta 要增加几(大于0) * @return */ public long incr(String key, long delta) { if (delta hmget(String key) { return redisTemplate.opsForHash().entries(key); } /** * HashSet * @param key 键 * @param map 对应多个键值 * @return true 成功 false 失败 */ public boolean hmset(String key, Map map) { try { redisTemplate.opsForHash().putAll(key, map); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * HashSet 并设置时间 * @param key 键 * @param map 对应多个键值 * @param time 时间(秒) * @return true成功 false失败 */ public boolean hmset(String key, Map map, long time) { try { redisTemplate.opsForHash().putAll(key, map); if (time > 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value) { try { redisTemplate.opsForHash().put(key, item, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 向一张hash表中放入数据,如果不存在将创建 * @param key 键 * @param item 项 * @param value 值 * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value, long time) { try { redisTemplate.opsForHash().put(key, item, value); if (time > 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 删除hash表中的值 * @param key 键 不能为null * @param item 项 可以使多个 不能为null */ public void hdel(String key, Object... item) { redisTemplate.opsForHash().delete(key, item); } /** * 判断hash表中是否有该项的值 * @param key 键 不能为null * @param item 项 不能为null * @return true 存在 false不存在 */ public boolean hHasKey(String key, String item) { return redisTemplate.opsForHash().hasKey(key, item); } /** * hash递增 如果不存在,就会创建一个 并把新增后的值返回 * @param key 键 * @param item 项 * @param by 要增加几(大于0) * @return */ public double hincr(String key, String item, double by) { return redisTemplate.opsForHash().increment(key, item, by); } /** * hash递减 * @param key 键 * @param item 项 * @param by 要减少记(小于0) * @return */ public double hdecr(String key, String item, double by) { return redisTemplate.opsForHash().increment(key, item, -by); } // ============================set============================= /** * 根据key获取Set中的所有值 * @param key 键 * @return */ public Set sGet(String key) { try { return redisTemplate.opsForSet().members(key); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 根据value从一个set中查询,是否存在 * @param key 键 * @param value 值 * @return true 存在 false不存在 */ public boolean sHasKey(String key, Object value) { try { return redisTemplate.opsForSet().isMember(key, value); } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将数据放入set缓存 * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ public long sSet(String key, Object... values) { try { return redisTemplate.opsForSet().add(key, values); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 将set数据放入缓存 * @param key 键 * @param time 时间(秒) * @param values 值 可以是多个 * @return 成功个数 */ public long sSetAndTime(String key, long time, Object... values) { try { Long count = redisTemplate.opsForSet().add(key, values); if (time > 0) { expire(key, time); } return count; } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 获取set缓存的长度 * @param key 键 * @return */ public long sGetSetSize(String key) { try { return redisTemplate.opsForSet().size(key); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 移除值为value的 * @param key 键 * @param values 值 可以是多个 * @return 移除的个数 */ public long setRemove(String key, Object... values) { try { Long count = redisTemplate.opsForSet().remove(key, values); return count; } catch (Exception e) { e.printStackTrace(); return 0; } } // ===============================list================================= /** * 获取list缓存的内容 * @param key 键 * @param start 开始 * @param end 结束 0 到 -1代表所有值 * @return */ public List lGet(String key, long start, long end) { try { return redisTemplate.opsForList().range(key, start, end); } catch (Exception e) { e.printStackTrace(); return null; } } /** * 获取list缓存的长度 * @param key 键 * @return */ public long lGetListSize(String key) { try { return redisTemplate.opsForList().size(key); } catch (Exception e) { e.printStackTrace(); return 0; } } /** * 通过索引 获取list中的值 * @param key 键 * @param index 索引 index>=0时， 0 表头，1 第二个元素，依次类推；index 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * @param key 键 * @param value 值 * @return */ public boolean lSet(String key, List value) { try { redisTemplate.opsForList().rightPushAll(key, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List value, long time) { try { redisTemplate.opsForList().rightPushAll(key, value); if (time > 0) { expire(key, time); } return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 根据索引修改list中的某条数据 * @param key 键 * @param index 索引 * @param value 值 * @return */ public boolean lUpdateIndex(String key, long index, Object value) { try { redisTemplate.opsForList().set(key, index, value); return true; } catch (Exception e) { e.printStackTrace(); return false; } } /** * 移除N个值为value * @param key 键 * @param count 移除多少个 * @param value 值 * @return 移除的个数 */ public long lRemove(String key, long count, Object value) { try { Long remove = redisTemplate.opsForList().remove(key, count, value); return remove; } catch (Exception e) { e.printStackTrace(); return 0; } } } 测试RedisController import com.boot.boot_redis.util.RedisUtil; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @author : kaifa * create at: 2019-10-28 14:22 * @description: 测试redis */ @RestController @RequestMapping(\"redis\") public class RedisController { @Autowired private RedisUtil redisUtil; final String key = \"rdsname\"; @RequestMapping(\"set\") public String setKey(String name){ redisUtil.set(key,name,7200); return \"success\"; } @RequestMapping(\"get\") public String getKey(){ if (redisUtil.hasKey(key)) return redisUtil.get(key) + \"\"; return \"\"; } } 访问：http://localhost:7006/redis/set?name=hlvy 接着访问:http://localhost:7006/redis/get 下一章:SpringBoot 中使用ehcache缓存 Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-11-04 17:21:46 "},"cache/cache.html":{"url":"cache/cache.html","title":"SpringBoot 中使用ehcache缓存","keywords":"","body":"Spring Boot ehcache使用与整合 Ehcache 也是 Java 领域比较优秀的缓存方案之一Spring Boot 中对此也提供了很好的支持，这个支持主要是通过 Spring Cache 来实现的。 ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。 项目地址:https://github.com/heng1234/springboot2.x/tree/master/boot_cache Spring cache缓存注解介绍 @CacheConfig 这个注解在类上使用，用来描述该类中所有方法使用的缓存名称，当然也可以不使用该注解，直接在具体的缓存注解上配置名称 @Cacheable 这个注解一般加在查询方法上，表示将一个方法的返回值缓存起来，默认情况下，缓存的 key 就是方法的参数，缓存的 value 就是方法的返回值。 @CachePut 这个注解一般加在更新方法上，当数据库中的数据更新后，缓存中的数据也要跟着更新，使用该注解，可以将方法的返回值自动更新到已经存在的 key 上 @CacheEvict 这个注解一般加在删除方法上，当数据库中的数据删除后，相关的缓存数据也要自动清除，该注解在使用的时候也可以配置按照某种条件删除（ condition 属性）或者或者配置清除所有缓存（ allEntries 属性） 开始使用ehcache pom.xml引入 org.springframework.boot spring-boot-starter-cache net.sf.ehcache ehcache 2.10.6 yml配置 需要说明的是config:classpath:/ehcache.xml可以不用写，因为默认就是这个路径。但ehcache.xml必须有。 spring: cache: ehcache: config: classpath:ehcache.xml ehcache.xml 在resources目录下新建config文件夹,在文件夹中建立ehcache.xml文件。 使用缓存 UserService import com.boot.boot_cache.entity.User; import com.boot.boot_cache.mapper.UserMapper; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cache.annotation.CacheConfig; import org.springframework.cache.annotation.CachePut; import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.util.List; /** * @author : kaifa * create at: 2019-10-22 10:10 * @description: user 业务层 */ @Service @CacheConfig(cacheNames = \"myuser\")//对应ehcache.xml配置文件配置的缓存名称 public class UserService { @Autowired private UserMapper userMapper; /** * 查询所有用户 * @return */ @Cacheable public List selectListAll(){ return userMapper.selectListAll(); } /** * 修改用户 * @param user * @return */ @CachePut(key = \"#user.id\") @Transactional public User updateUser(User user){ userMapper.updateUser(user) ; return userMapper.findUserById(user.getId());//这里修改后需要查询一遍进行缓存 } /** * 查询所有用户 * @return */ @Cacheable(key = \"#id\") public User findUserById(Integer id){ return userMapper.findUserById(id); } /* @CacheEvict(key = \"#user.id\") @Transactional public void updateUser(User user){ userMapper.updateUser(user) ; }*/ } UserMapper import com.boot.boot_cache.entity.User; import java.util.List; /** * @author : kaifa * create at: 2019-10-22 10:10 * @description: user mapper接口 */ public interface UserMapper { /**查询所有用户*/ List selectListAll(); /** * 修改用户信息 * @param user * @return */ int updateUser(User user); /** * 根据id查询 * @param id * @return */ User findUserById(Integer id); } mapper.xml update T_USER USERNAME = #{userName}, password = #{password}, id = #{id} select id,username,password,create_time createTime from t_user select id,username userName,password,create_time createTime from t_user where id = #{id} controller import com.boot.boot_cache.entity.User; import com.boot.boot_cache.service.UserService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.List; /** * @author : kaifa * create at: 2019-10-22 10:16 * @description: user controller */ @RestController @RequestMapping(\"user\") public class UserController { @Autowired private UserService userService; /** * 查询所有用户 * @return */ @RequestMapping(\"userList.do\") List selectListAll(){ return userService.selectListAll(); } /** * 修改用户 * @return */ @RequestMapping(\"updateUser.do\") String updateUser(User user){ userService.updateUser(user); return \"success\"; } /** * 根据id查询 * @return */ @RequestMapping(\"findUserById.do\") User findUserById(Integer id){ return userService.findUserById(id); } } 访问http://localhost:7007/user/findUserById.do?id=1 第一次会查询数据库 第二次会进入缓存不会访问数据库 接着访问修改数据 http://localhost:7007/user/updateUser.do?id=1&userName=heng&password=1234567 然后继续访问查询会走缓存 具体看代码 项目地址:https://github.com/heng1234/springboot2.x/tree/master/boot_cache 下一章springboot使用拦截器-过滤器-servlet-listener Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-11-06 10:40:54 "},"Init_filter_servlet/ifs.html":{"url":"Init_filter_servlet/ifs.html","title":"springboot使用拦截器-过滤器-servlet-listener","keywords":"","body":"springboot使用 拦截器 过滤器 servlet 一、springboot使用拦截器 一个拦截器，只有preHandle方法返回true，postHandle、afterCompletion才有可能被执行；如果preHandle方法返回false，则该拦截器的postHandle、afterCompletion必然不会被执行。拦截器不是Filter，却实现了Filter的功能，其原理在于： 所有的拦截器(Interceptor)和处理器(Handler)都注册在HandlerMapping中。 Spring MVC中所有的请求都是由DispatcherServlet分发的。 当请求进入DispatcherServlet.doDispatch()时候，首先会得到处理该请求的Handler（即Controller中对应的方法）以及所有拦截该请求的拦截器。拦截器就是在这里被调用开始工作的。 新建WebMvcConfigurer实现WebMvcConfigurer import com.boot.inte_filter_servlet.interceptor.init.UserInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry; /** * @author : kaifa * create at: 2019-11-04 18:18 * @description: 拦截器配置 */ @Configuration public class WebMvcConfigurer implements org.springframework.web.servlet.config.annotation.WebMvcConfigurer { @Autowired private UserInterceptor userInterceptor; //配置拦截的资源以及放行的资源 @Override public void addInterceptors(InterceptorRegistry registry) { /** * 拦截器按照顺序执行 */ //拦截Controller所有 /*/** userInterceptor是定义的拦截器 registry.addInterceptor(userInterceptor) //拦截的url /**是所有 .addPathPatterns(\"/**\") //不拦截url .excludePathPatterns(\"/user/notInit\") //放行静态资源 .excludePathPatterns(\"/img/**\",\"/css/**\",\"/fonts/**\",\"/js/**\"); } //配置静态资源的位置 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { } } 定义拦截器 UserInterceptor实现HandlerInterceptor import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /** * @author : kaifa * create at: 2019-11-05 10:24 * @description: 拦截器 */ @Component public class UserInterceptor implements HandlerInterceptor { /** * log日志 */ Logger log= LoggerFactory.getLogger(this.getClass()); /** * 预处理回调方法，实现处理器的预处理（如检查登陆），第三个参数为响应的处理器，自定义Controller * 返回值：true表示继续流程（如调用下一个拦截器或处理器）；false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应； */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { log.info(\"----------拦截器---Controller方法调用之前被拦截，放行...\"); return true; } /** * 后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。 */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { log.info(\"----------拦截器---Controller方法调用之后被拦截\"); } /** * 整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { log.info(\"----------拦截器---日志记录....\"); } } controller测试拦截器 import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @author : kaifa * create at: 2019-11-05 11:08 * @description: 测试拦截器 */ @RestController @RequestMapping(\"user\") public class UserController { @RequestMapping(\"init\") public String init(){ return \"init\"; } @RequestMapping(\"notInit\") public String notInit(){ return \"notInit\"; } } 访问http://localhost:7008/user/init 访问http://localhost:7008/user/notInit则不会拦截因为拦截器配置了不拦截此路径 二、springboot使用过滤器注解版 在启动类加上@ServletComponentScan注解 UserWebFilter import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.core.annotation.Order; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import java.io.IOException; /** * @author : kaifa * create at: 2019-11-05 17:59 * @description: 使用拦截器注解版 */ @Order(1)//优先级 @WebFilter(filterName = \"userfilter\",urlPatterns = \"/*\") public class UserWebFilter implements Filter { /** * log日志 */ Logger log= LoggerFactory.getLogger(this.getClass()); /** * 该方法由 web 容器调用,以指示 Filter 已经投入使用。servlet容器在实例化过滤器之后调用init方法一次。在要求过滤器执行任何过滤工作之前，init方法必须成功完成。当 init 方法出现以下情况时 Filter 将不生效: * a.抛出了 ServletException 异常; * b.在一段时间内没有返回结果(超时了) * @param filterConfig * @throws ServletException */ @Override public void init(FilterConfig filterConfig) throws ServletException { log.info(\"调用init()方法初始化实例，在项目启动时候调用一次\"); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; String requestURI = request.getRequestURI(); StringBuffer requestURL = request.getRequestURL(); log.info(\"requestURI:\" +requestURI+\" \"+\"requestURL:\"+requestURL); log.info(\"每一请求只调用方法的doFilter()进行真正的过滤处理，每次发出请求都会调用\"); filterChain.doFilter(request, servletResponse); } @Override public void destroy() { log.info(\"停止服务器调用destroy()方法，销毁实例，释放资源，项目停止时销毁一次\"); } } 测试过滤器 import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; /** * @author : kaifa * create at: 2019-11-05 18:23 * @description: 测试过滤器 */ @RestController @RequestMapping(\"filter\") public class FilterController { @RequestMapping(\"filterTest\") public String filterTest(){ return \"this filter\"; } } 启动项目 访问url 停止工程 三、springboot使用servlet UserServlet import lombok.extern.slf4j.Slf4j; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; /** * @author : kaifa * create at: 2019-11-06 09:50 * @description: servlet */ @WebServlet(urlPatterns = \"/user\") @Slf4j public class UserServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { log.info(\"user--doGet方法\"); resp.setHeader(\"Content-Type\",\"text/html;charset=UTF-8\"); resp.getOutputStream().write(\"user--doGet方法\".getBytes(\"UTF-8\")); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 访问http://localhost:7008/user 四、springboot使用listener import lombok.extern.slf4j.Slf4j; import javax.servlet.annotation.WebListener; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; import java.util.concurrent.atomic.AtomicInteger; /** * @author : kaifa * create at: 2019-11-06 09:57 * @description: 监听器session * * * */ @Slf4j @WebListener public class MyListener implements HttpSessionListener { private AtomicInteger onLineCount = new AtomicInteger(0); /** * ServletContextListener -- 监听servletContext对象的创建以及销毁 * * contextInitialized(ServletContextEvent arg0) -- 创建时执行 * * contextDestroyed(ServletContextEvent arg0) -- 销毁时执行 * * HttpSessionListener -- 监听session对象的创建以及销毁 * * sessionCreated(HttpSessionEvent se) -- 创建时执行 * * sessionDestroyed(HttpSessionEvent se) -- 销毁时执行 * * ServletRequestListener -- 监听request对象的创建以及销毁 * * requestInitialized(ServletRequestEvent sre) -- 创建时执行 * * requestDestroyed(ServletRequestEvent sre) -- 销毁时执行 * * ServletContextAttributeListener -- 监听servletContext对象中属性的改变 * * attributeAdded(ServletContextAttributeEvent event) -- 添加属性时执行 * * attributeReplaced(ServletContextAttributeEvent event) -- 修改属性时执行 * * attributeRemoved(ServletContextAttributeEvent event) -- 删除属性时执行 * * HttpSessionAttributeListener --监听session对象中属性的改变 * * attributeAdded(HttpSessionBindingEvent event) -- 添加属性时执行 * * attributeReplaced(HttpSessionBindingEvent event) -- 修改属性时执行 * * attributeRemoved(HttpSessionBindingEvent event) -- 删除属性时执行 * * ServletRequestAttributeListener --监听request对象中属性的改变 * * attributeAdded(ServletRequestAttributeEvent srae) -- 添加属性时执行 * * attributeReplaced(ServletRequestAttributeEvent srae) -- 修改属性时执行 * * attributeRemoved(ServletRequestAttributeEvent srae) -- 删除属性时执行 * */ @Override public void sessionCreated(HttpSessionEvent se) { se.getSession().getServletContext().setAttribute(\"onLineCount\", onLineCount.incrementAndGet()); log.info(\"session初始化完成\"); } @Override public void sessionDestroyed(HttpSessionEvent se) { log.info(\"session销毁\"); se.getSession().getServletContext().setAttribute(\"onLineCount\", onLineCount.decrementAndGet()); } } Copyright © 2020 java交流群:553997290 all right reserved，powered by Gitbook时间： 2019-11-06 10:38:25 "}}